- Django vs Flask
------------------
- Django is Full-fledged framework within builtin features like ORM, Session management, Token management, Middleware, etc
- Flask is mini-framework, where we can create an application server in just 10 lines of code.
- Django has built-in ORM, whereas in flask, we need to use the sqlalchemy ORM.
- Django comes with Django Template language, whereas in flask, we need to use jinja2 templates.
- Flask supports both sql and no-sql databases, whereas django is suitable for only relational databases.
- By default, django comes with batteries to be production ready, whereas in flask, we need to know what all needs to be added to our application.

- Conclusions
	- flask is suitable
		- when no-sql database is of choice, or
		- when small utility application is needed, or
		- when we need quick development
	- Django is suitable
		- when full-fledged application is needed,
		- when production-ready application is needed,

- Django MVC & MVT
-------------------
- MVC - Model, View, Controller
- MVT - Model, View, Template

- Model
	- It handles the data representation & db schema
	- It serves as interface to data stored in database itself, and also allows you to
	  interact with your data without having to perturbed with all complexities of the underlying database.
- View
	- It represents what you see from web application, or REST API.
- Controller
	- URL dispatcher

- Template
		- Presentation layer when working with web application

Django process flow
--------------------
Step 1: user will hit the endpoint in browser
Step 2: It will go to project level  urls.py
Step 3: It will go to application level urls.py
Step 4: It will go to  application level views.py
Step 5: it will run business logic & models.py; and response is in reverse direction

- Django Project Structure
-------------------------
Project
	Urls.py      ----------->  all project URLs routing
	Settings.py  ----------->  all dB settings and all with be here
	at App Level
		Urls.py   -----------> this app level urls.py will route endpoints, to app views.py
		Views.py  ----------->   business logic
		Models.py ----------->   dB table schemas
		Tests.py  ----------->   unit tests for the specific app related code
		admin.py  ----------->   It will be used for registering what models to be seen in admin page

- Django Project Working Procedure
---------------------------------
Step 1: Creating the project, using the command
			django-admin startproject projectName

Step 2: Creating the app, within project,
			python manage.py startapp appname

Step 3: In settings.py file, in apps section, add the application name, to register.

Step 4: In app-level, models.py, we need to add the db table schemas as classes,
		and do makemigrations and migrate, to apply schema changes to the database.

Step 5: In the app-level, views.py file, we need to write the business logic.
		In app-level, create urls.py file, we need to link the views with the url endpoints

Step 6: Now, run the application, using the command
			python manage.py runserver


- function based views vs class based views
-------------------------------------------
- Function based views are simple and mostly used for custom functionality.
	Pros
		- explicit code, easy to read, and straightforward usage of decorators.
	Cons
		- Hard to extend and reuse the code.
		- We need to write explicitly for handling all HTTP methods via conditional branching.
- Class Based Views makes use of builtin classes for any kind.
	Pros
		1) Code reuseability
			— A view class can be inherited by another view class and modified for a different use case.
		2) DRY( Don't repeat yourself) principle
			— Means class based views help in reducing code duplication
		3) We can extend the Code using Mixins, for any further customizations
		4) Availability of a lot of kinds of Built-in generic class-based views
		5) Code structuring — A class based view helps to respond different http request with different class instance methods instead of conditional branching statements inside a single function based view.

	Cons
		- Harder to read, as each class based view has specific way of writing.
		- Implicit code flow
		- Use of view decorators require extra import, or method override


Django Migrations
-----------------
- In Django project, in each app folder level, a folder named "migrations" will be present.
	In it, there will be python scripts like
		001__CHANGENAME_TIMESTAMP.py
		002__CHANGENAME_TIMESTAMP.py
	When we make changes in models.py file, and run "python manage.py makemigrations", these files
	will be created.

- commands
	Python manage.py startproject <Project>--> creates django project with given name "Project"
	Python manage.py startapp <appname>   ---> creates django app, with given "appname"
	Python manage.py runserver 			 ----> Will run local server
	Python manage.py createsuperuser	 ----> creates a superuser, with given username and password
	Python manage.py testserver			 ----> Runs a development server with data

	Python manage.py makemigrations ----> Will create the migration files, in app/migrations folder
	Python manage.py showmigrations ----> will see the status of migrations, on to the database.
	python manage.py sqlmigrate <appname> <migration number eg. 0001 or 0004>
									----> will display SQL statements for a specific migration of app.
	Python manage.py migrate        ----> will Apply the migrations files, on to the database.
	python manage.py migrate 		----> prune option allows deleting nonexistent migrations from the django_migrations table.
	python manage.py squashmigrations---> Squashes an existing set of migrations( from first until specified) into a single new one

	python manage.py diffsettings  	 ---> displays the difference between current settings.py & Django's default settings

	python manage.py shell      	 ---> runs a python interactive interpreter
	python manage.py dbshell      	 ---> runs command-line client for specified database or default

	python manage.py dumpdata  	 	 ---> Outputs the contents of database as a fixture of given format
	python manage.py inspectdb	 	 ---> Inspect the database tables in given database and outputs a django model module
	python manage.py loaddata	 	 ---> Installs the named fixtures in the database
	python manage.py flush  	 	 ---> Removes all data from databse, including data added during migration
	python manage.py sqlflush  	 	 ---> Returns a list of the SQL statements required to return all tables in the database to the state
	python manage.py sqlsequencereset---> Prints the SQL statements for resetting sequences for given app name(s)

	python manage.py check			----> checks entire project for potential problems
	python manage.py compilemessages----> compiles .po files to .mo files for use with builtin gettext support
	python manage.py createcachetable---> creates a cache table in django application
database if none is provided
	python manage.py makemessages 	 ---> Runs over entire source tree of current directory and pulls out all strings marked for translation
	python manage.py sendtestmail 	 ---> sends a test email to email addresses specified as arguments


- For rollbacking migrations, we need to identify the last migration to which we want to revert and use its migration file name as migration target
	python manage.py migrate app_name target_migration


- Django signals
-----------------
- They are the database triggers, pre_save, post_save, etc
- Django signals contain two parts: the senders and the receivers
	- the sender is the one responsible to dispatch a signal, and
	- the receiver is the one who will receive this signal and then do something.
- A receiver must be a function or an instance method which is to receive signals.
- A sender must either be a Python object, or None to receive events from any sender.
- The connection between the senders and the receivers is done through “signal dispatchers”,
  which are instances of Signal, via the connect method.
- So to receive a signal, you need to register a receiver function that gets called
  when the signal is sent by using the Signal.connect() method.

- Ex1 :
	from django.contrib.auth.models import User
	from django.db.models.signals import post_save

	def save_profile(sender, instance, **kwargs):
		instance.profile.save()

	post_save.connect(save_profile, sender=User)

- Ex2 :
	Another way to register a signal, is by using the @receiver decorator:

	from django.contrib.auth.models import User
	from django.db.models.signals import post_save
	from django.dispatch import receiver

	@receiver(post_save, sender=User)
	def save_profile(sender, instance, **kwargs):
		instance.profile.save()

- Django Hooks
---------------
- Hooks are the callables that you want to execute when a specified signal happened.

	  # app/signals.py
		from django.db.models.signals import post_save
		from django.dispatch import receiver
		from django.db import transaction
		from .models import Book

		@receiver(post_save, sender=Book)
		def post_save_handler(sender, **kwargs):
			book = kwargs.get(‘instance’, None)
			created = kwargs.get(‘created’, False)
			raw = kwargs.get(‘raw’, False)

- In signals.py, we will put all the hooks and signal declarations, and
  these signals are imported in the appconfig class ready method

	  # myapp/apps.py
		from django.apps import AppConfig
		class MyAppConfig(AppConfig):
		 name = “myapp”
		 label = “myapp”
		 verbose_name = “My App”
		def ready(self):
		 # importing signal handlers
		 import myapp.signals


- Django Serializers
--------------------
- Serializers allow complex data such as querysets and model instances to be converted to native
	Python datatypes that can then be easily rendered into JSON, XML or other content types.
- Serializers also provide deserialization, allowing parsed data to be converted back into complex
	types, after first validating the incoming data.

	from rest_framework import serializers
	from .models import Product

	class ProductSerializers(serializers.ModelSerializer):
		class Meta:
			model = Product
			fields = '__all__'

- serializer vs model serializer
	- The ModelSerializer class is the same as a regular Serializer class, except that:
		- It will automatically generate a set of fields for you, based on the model.
		- It will automatically generate validators for the serializer, such as unique_together validators.
		- It includes simple default implementations of .create() and .update().

- Django Models
--------------
- Under each app folder in Django project, we have models.py file.
- It is the placeholder for the database schema for the app in that project.
- Each class represents a DB table
- Ex:
	Class  MyTable(model.Model):
		Col1 = models.CharFiled(max_length= 20)
		Col2 = model.IntegerFiled(default=0)

- Session Management
-------------------
	- Django uses Django-sessions table to store the session related information
	- we can configure it

- Django Authentication
----------------------
	- Django supports session based authentication for the UI , means web applications
	- And, Token-based Authentication   -- for REST APIs
	- Also, I worked with JWT and OAuth for authentication

- Django Middleware
--------------------
- Middleware is processes that acts between request and response execution
- each middleware carries a performance overhead for each request.

	- CsrfViewMiddleware  	- ensures that the CSRF token is present and valid on form submissions.
	- LocaleMiddleware 		- for language translations if you choose to internationalize your project.
	- GZipMiddleware 		- will compress the response
	- CommonMiddleware  	- handles a variety of Django settings to control certain aspects of your project.
							  Ex: APPEND_SLASH setting will redirect a request like
										  example.com/accounts to example.com/accounts/
	- SessionMiddleware     - manages the session state of a user

	- Other examples include SecurityMiddleware, SessionMiddleware, AuthenticationMiddleware.
	- I created a custom Middleware for counting the User requests and analytics on it.

				   +--------- SecurityMiddleware --------------+
				   |+-------- SessionMiddleware --------------+|
				   ||+------- CommonMiddleware --------------+||
				   |||+------ CsrfViewMiddleware -----------+|||
				   ||||+----- AuthenticationMiddleware ----+||||
				   |||||+---- MessageMiddleware ----------+|||||
				   ||||||+--- XFrameOptionsMiddleware ---+||||||
				   |||||||                               |||||||
	HttpRequest =================> view function ==================> HttpResponse
				   |||||||                               |||||||


		class CountRequestsMiddleware:

			def __init__(self, get_response):
				self.get_response = get_response
				self.count_requests = 0
				self.count_exceptions = 0

			def __call__(self, request, *args, **kwargs):
				self.count_requests += 1
				logger.info(f"Handled {self.count_requests} requests so far")
				return self.get_response(request)

	- writing custom middleware; we can create middleware.py file

			class AwesomeMiddleware:
				def __init__(self, get_response):
					self.get_response = get_response

				def __call__(self, request):
					return self.get_response(request)

	  After creating the middleware, you add it to your settings.

			# project/settings.py

			MIDDLEWARE = [
				'django.middleware.security.SecurityMiddleware',
				...,
				'middleware.AwesomeMiddleware',
			]
	 - another middleware example,
		import logging
		import time

		logger = logging.getLogger(__name__)


		class AwesomeMiddleware:
			def __init__(self, get_response):
				self.get_response = get_response

			def __call__(self, request):
				before_timestamp = time.time()
				logger.info(f"Tracking {before_timestamp}")

				response = self.get_response(request)

				after_timestamp = time.time()
				delta = after_timestamp - before_timestamp
				logger.info(f"Tracking {after_timestamp} for a delta of {delta}")

				return response

	- another example
		import logging
		import time

		logger = logging.getLogger(__name__)


		class AwesomeMiddleware:
			def __init__(self, get_response):
				self.get_response = get_response

			def __call__(self, request):
				before_timestamp = time.time()
				logger.info(f"Tracking {before_timestamp}")

				response = self.get_response(request)

				after_timestamp = time.time()
				delta = after_timestamp - before_timestamp
				logger.info(f"Tracking {after_timestamp} for a delta of {delta}")

				return response

			def process_view(self, request, view_func, view_args, view_kwargs):
				logger.info(f"Running {view_func.__name__} view")
	- JSON Error middleware - https://rednafi.github.io/reflections/return-json-error-payload-instead-of-html-text-in-drf.html


- Django ORM - object relational mapper
---------------------------------------
- I will use ORM for small queries
- For large queries, I prefer to use raw SQL code. Because, it will be scalable, readable and fast to use when multiple joins are present.

- primary key
	can be addressed either with id (if defined a column with id), or pk (in general)
	To get the primary key field name, the ORM query is
		TableName._meta.pk.name

- ORM relationships
	A) One-to-One relationship:
		- Each instance of one entity is linked to exactly one instance of another entity.
		- It is usually represented by a unique identifier shared between the entities.

	B) One-to-Many relationship:
		- An entity instance is associated with multiple instances of another entity.
		- It is represented by a foreign key in the "many" side pointing to the primary key of the "one" side.

	C) Many-to-Many relationship:
		- Multiple instances of one entity are connected to multiple instances of another entity.
		- It is represented using an intermediate table that establishes the associations between the entities.

- get_or_create query will result in two values: object and an bool value(true/false), whether object is already created or not.


	EmpObj, created = Employee.objects.get_or_create(
		first_name='John',
		last_name='Lennon',
		defaults={'joinigDate': date(2023, 04, 8)},
	)

	# get_or_create() didn't have to create an object.
	>>> created
	False

- value() and only()
	- values() method returns a QuerySet that contains dictionaries instead of model instances.
		- Each dictionary represents an object from the queryset and contains only the fields specified in the values method.
	- only() method returns a QuerySet that includes only the specified fields of the model.
		- It allows us to reduce memory usage by fetching only the necessary fields for a particular operation.

- N+1 problem
	- This problem occurs in ORMs.
	- The problem occurs when we have a query that loads a set of objects, and then each object requires an additional query to load its associated data.
	  If we have N objects, this can result in N + 1 queries being executed against the database, where the first query retrieves the N objects, and then one additional query is executed for each of the N objects to retrieve the associated data.
	- It means larger the value of N, the more queries will be executed, the larger the performance impact.

	- In Django, we can use the select_related and prefetch_related methods to address the N+1 problem and improve the performance of wer database queries.

	- Problem
		if there are two models, Author and Book, where each Book is associated with an Author, and we want to retrieve all the books and the associated authors:

			books = Book.objects.all()
			for book in books:
				author = book.author  # This line triggers an additional query to load the associated author

	- Solution

			books = Book.objects.select_related('author').all()
			for book in books:
				author = book.author  # This line does not trigger an additional query

	- Problem
		if there are two models, Category and Product, where each Product can belong to multiple categories.
		we want to retrieve all the products and the associated categories:

			products = Product.objects.all()
			for product in products:
				categories = product.categories.all()  # This line triggers an additional query to load the associated categories

	- Solution

			products = Product.objects.prefetch_related('categories').all()
			for product in products:
				categories = product.categories.all()  # This line does not trigger an additional query


- select_related vs prefetch_related
	- select_related
		- "follows" foreign-key relationships, selecting additional related-object data when it executes its query.
	- prefetch_related
		- does a separate lookup for each relationship, and does the "joining" in Python.

	- select_related is used to retrieve related objects using a SQL join, which reduces the number of queries executed against the database.
	- prefetch_related is used to retrieve related objects using separate queries, but it does so in a more efficient way than executing separate queries for each object.

- null=True vs blank=True
	- null=True affects the database schema and allows the field to have no value,
	  while blank=True affects the Django forms and allows the field to be left blank by the user.

	- It's possible to set both options on a field if we want to allow both empty values and blank form submissions.

- Django ORM Exceptions
	1) DoesNotExist
		- Raised when a query does not return any results for a specific model instance.
		- To address this exception, we can use a try-except block to catch the exception and handle it appropriately, such as redirecting the user to a custom error page or displaying a helpful message.

	2) MultipleObjectsReturned
		- Raised when a query returns multiple results for a specific model instance when only one is expected.
		- To address this exception, we can use a more specific query to retrieve a single object, such as filtering on a unique field or using the first() method instead of get().
		- Alternatively, we can handle the exception by catching it in wer code and taking appropriate action, such as raising a custom error or returning a default value.

	3) FieldError
		- Raised when a field name is invalid or a query contains an invalid field.
		- To address this exception, we should check wer code for typos or syntax errors in wer query or field names, and make sure that we're using the correct syntax for querying related models and fields.

	4) ValidationError
		- Raised when a model instance fails validation (e.g. due to invalid data or missing required fields).
		- To address this exception, we should ensure that wer code validates user input and model instances before saving them to the database, and handle validation errors by displaying appropriate error messages to the user.

	5) IntegrityError
		- Raised when a database constraint is violated (e.g. unique constraint or foreign key constraint).
		- To address this exception, we should ensure that wer code checks for and handles database constraints appropriately, such as by catching and handling constraint violations or displaying helpful error messages to the user.

	6) OperationalError
		- Raised when a database operation fails due to a connection issue or other database error.
		- To address this exception, we should ensure that wer code handles database connection issues and retries failed operations when possible, or displays helpful error messages to the user when a database operation fails.


- Optimizing ORM queries - https://schegel.net/posts/optimizing-django-orm-queries/


- Model Inheritance
	class Vehicle(models.Model):
		title = models.CharField(...)
		Name = models.CharField(....)

		class Meta:
			 abstract = True

	class Car(Vehicle):
		color = models.CharField()

	class Bike(Vehicle):
		fuel_average = models.IntegerField(...)

- Django Manager
	- Manager is some kind of interface between application and the database.
	- we can define custom base querysets, for the models.

- Custom model field
	from django.db import models

	class MyField(models.Field):

		description = "my field details"

		def __init__(self, *args, **kwargs):
			kwargs['max_length'] = 50
			super().__init__(*args, **kwargs)

	The Field.__init__() method takes the following parameters:
		verbose_name, name, primary_key, max_length, unique, blank, null, db_index, etc

- Django ORM vs SQLAlchemy

- Multiple Databases in Django Project

	DATABASES = {
		'default': {
			'NAME': 'app_data',
			'ENGINE': 'django.db.backends.postgresql',
			'USER': 'postgres_user',
			'PASSWORD': 's3krit'
		},
		'users': {
			'NAME': 'user_data',
			'ENGINE': 'django.db.backends.mysql',
			'USER': 'mysql_user',
			'PASSWORD': 'priv4te'
		}
	}

	$ ./manage.py migrate --database=users
	$ ./manage.py migrate --database=customers

- Django Cheatsheet
	https://cheatography.com/papousekp/cheat-sheets/django-class-based-views/
	https://cheatography.com/lewiseason/cheat-sheets/django-models/

- Django Test Setup

	Django Settings.py

		TEST_RUNNER = 'xmlrunner.extra.djangotestrunner.XMLTestRunner'
		TEST_OUTPUT_FILE_NAME = 'unit.xml'

	requirements.txt
		unittest-xml-reporting==3.0.2

	python_install.sh

		#!/usr/bin/env bash

		sudo apt update
		sudo apt --yes install software-properties-common;
		sudo add-apt-repository ppa:deadsnakes/ppa;
		sudo apt update; sudo apt --yes install python3.7;
		sudo rm /usr/bin/python3;
		sudo ln -s /usr/bin/python3.7 /usr/bin/python3
		curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py;
		python3 get-pip.py --force-reinstall;
		sudo apt-get --yes install python3.7-dev;
		sudo apt-get --yes install libpq-dev;
		pip3 install virtualenv;
		virtualenv -p python3 env1;

- django modules
--------------
	- django-debug-toolbar for analyzing or removing duplicate db calls
	- drf-nested-routers for URL routing management
	- django-extensions  for utilities like db shell, etc.


- drf renderers
	- JSONRenderer
	- BrowsableAPIRenderer
	- TemplateHTMLRenderer
	- AdminRenderer
	- HTMLFormRenderer
	- I also created a customer PlainTextRenderer

- drf permissions
	- persmissions help to restrict access to views or endpoints in an API.
	- we need to define permissions_classes class variabe in views, to use them.
	- Types
		1) IsAuthenticated:
			- Allows access to authenticated users only.
			- Unauthenticated users will receive a 401 Unauthorized response.

		2) IsAdminUser:
			- Allows access to admin users only.
			- Non-admin users will receive a 403 Forbidden response.

		3) AllowAny:
			- Allows access to all users, authenticated or not.

		4) IsAuthenticatedOrReadOnly:
			- Allows access to authenticated users for all HTTP methods except POST, PUT, and DELETE, which are restricted to authenticated users only.

		5) DjangoModelPermissions:
			- Allows access to users with specific model permissions defined in Django's permission system.
			- For example, a user with the view permission for a particular model will be able to access views or endpoints that use this permission.

		6) DjangoObjectPermissions:
			- Allows access to users with specific object-level permissions defined in Django's permission system.
			- This permission requires that the model in question has a corresponding permission set up in Django's permission system.


Django Ref blogs/tutorials
	- https://djangotricks.blogspot.com/


TODO
	- Django forms - https://justdjango.com/blog/dynamic-forms-in-django-htmx
	- Django Cacheing - https://blog.sentry.io/2022/10/24/django-performance-improvements-part-4-caching-in-django-applications/
