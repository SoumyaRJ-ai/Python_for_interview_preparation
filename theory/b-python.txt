Python Modules
	Requests     : for consuming APIs
	Re           : for regular expressions
	Scikit-learn : for machine learning - I used for creating linear regression model
	BeautifulSoap: for parsing html content. Used when I worked on web crawling/Scrapping
	NumPy        : Advanced linear algebra and NumPy array operations
	Matplotlib   : Visualization and data plotting in 2 or 3 dimensions.
	IPython      : Increasing console interactivity.
	Jupyter notebook: for interactively exploring the datasets and other functions
	Pandas       : Data manipulation and analysis, mainly through dataframes and tables.
	boto3        : For connecting and managing AWS Cloud resources
	paramiko	 : for connecting to linux machines
	fabric		 : for connecting to windows machines

	file system modules like
		csv files with csv and pandas modules
		json files with json and pandas modules
		yaml files with pyyaml module
		Excel files with openpyxl, Xlsxwriter, xlrd and pandas modules
		pdf files  with reportlab, pypdf2 modules
		image files with Pillow and tesserect modules

Frameworks
	Django , flask, fastapi

Files i worked with
--------------------
	- pdf files using modules like reportlab, pypdf2
	- image files using tesserect, Pillow
	- CSV, .dat files, tsv files with pandas

Python Questions
=================
- Basic Data Types - Int, Float, Str, None, bool
- Built-in Data Structures - List, Tuple, set, Dictionary

- Mutable objects
	- supports inplace changes
	- list, set, dict
- Immutable objects
	- doesnt support inplace changes
	- tuple, string, frozenset

- List
	- Mutable object - it is editable. we can add , remove any element in it.
	- indexed and retains the order of initialization
	- will retain duplicates and can store any data type
- Tuple
	- same as a list, but once created, we can't change any element in it .
	- it is immutable object
- Set
	- mutable object - we can edit it
	- unordered and wont store duplicates
	- will store only immutable objects(int, float, string, frozenset, tuple)
- Dictionaries
	- They are called as HashMap in other languages
	- They store in key: value relation
	- keys should be immutable and unique, and hashable
	- ex: {1:2, 3:4, 5:6}

- conclusions
	- List is suitable when the order of storage is needed and/or if there were more writes.
	- Dict suitable when there were more reads
	- Set is suitable when unique values are needed and/or set operations like union,
	  intersection, etc are needed.
	- Tuple is suitable when there need to be immutability

hashable
	- An object is hashable if it has a hash value which never changes during its lifetime

- List vs Tuple
	- List is mutable object, means we can edit the object like append, delete, ..
	- Tuple are faster than list
		- Tuples are stored in a single block of memory. Tuples are immutable so,
		It doesn't require extra space to store new objects.
		- Lists are allocated in two blocks:
			1. fixed one with all the Python object information, and
			2. variable sized block for the data.
	- Tuples is that they use less memory where lists use more memory
	- USAGE:
	List is used when we need to make changes in code, say like adding values while loop .
	Tuple is used when we wont change something in the code

- append vs extend
	- both adding elements in last of list
	- with append, we can add either single element or an iterable
	- it will add at the end as it is
	- whereas extend works with iterable objects only, but adds in same dimension

- List vs Dict
	- list is suitable when order of element is preferred.
	- dict is suitable when there were more reads. dict has O(1) for search an element, as
	  it stored each element uniquely with its hash.

- List vs Array
	- list is builtin data structure in python
	- we can either have all elements of same type, or different type

	- array is available from numpy
	- IN array, we need to have all elements of same type.
	- whenever i have to store all elements of same type, as arrays are more performant than lists.

- Pickling
	- Pickling means Python object to flat file conversion
	- unpickling means flat file to python object conversion
	- This process is also called serialization/deserialization
	- Other serialization formats are json, yaml, ...
	- we use it when we need to pass python object to other language processes, and vice versa.

- lambda function
	- one liner
	- SYNATAX is lambda arguments: expression
	- We need not define complete function. We can use instantly for the purpose.
	- I use it when working with higher order function like map(), filter(), zip() and reduce()
	- example
		- if we have to increment all values in a list by one,
				map(lambda x:x + 1, range(10))

- List comprehension
	- rewriting the for loop in single line.

- funtion Overloading
	- function overloading is not supported in python
	- only function overwriting is present.

	- In java,
		If you create function with 2 arguments and another with 3 arguments,
		we can call each invidivally.
	- But, in python, it will overwrite with the latest function/method

- range() vs xrange()
	- In python 2,
		- range will give list of integers
		- xrange will give a xrange object, which will give values only when iterated.
	- In python3, xrange is renamed as range.

- copy vs deepcopy
	- This problem occurs in mutable objects i.e., list, dictionary
	- when working with mutables, when we assign a
			list1 = list2
		it will not create new object
		it
		both wil refer to the same object
		so, if you change in one list, it will reflect in others
		to avoid, we go with copy
		using
		copy -- module

- try-exception blocks
	1) Try   --- executed every time
	2) Except--- executed when there is exception in try block
				 , check if it can handle break code if it cant

	3) Else  --- executed when no exception in try block
	4) Finally-- exceutd everytime  — irrespective of failure  –
				 it is like for file closing, etc ….

- OOP
	- Object Oriented Programming
		- I use Object-Oriented Programming and Design predominantly.
		- It gives us the scalability in code to adapt any requirement changes.

 	- There are 4 principles:
		1) ENCAPSULATION - with public , protected and private variables/methods
				public variable -- it a variable is starting with no underscore
				protected variable -- if it is starting with SINGLE underscore
				private variable -- if it is starting and ending with TWO underscores

			We can access all variables  of all classes irrespective of public or private or protected.
			This name mangling is to avoid accidental override

		2) ABSTRACTION: It is a process of hiding implementation details and showing only
						functionality to the user.

		3) INHERITANCE:
				- python supports single, multiple and multi-level inheritance, using MRO (Method Resolution Order)
						single ---> one parent & one child
						multiple --> two parents & one child
						multi-level -->  parent1 => child ==> subChild
				- Method Resolution Order is the order in which base classes are searched for a member during lookup.

		4) POLYMORPHISM: It is an ability of object to behave in multiple form.
			Ex: + operator, It will work differently in different contexts
						addition operation between integers
						List concatenation operator between lists
						Tuple concatenation operator between tuples

- class Variables vs Instance Variables
	- Class variable is used to work with class methods
	- Instance variables are just associated with instance methods

	- Say, we have created  5 instances  from a car class
	  We need to give unique id to all the car instances,
	  Then, We can track using the class variables
	- Instance variables of each instance, will be isolated
	  from that of other instances.

- python 2 to 3
	- I used python built-in module, lib2to3 , for migrating from python2 to python3.
	- Wrote code with six module to write compatible code, for both python2 and 3, during migrating phase.
	- Difference between python2 and python3
		- Default encoding is ASCII in python2, whereas it  is UTF-8 in python3
		- There were both old & new style classes in python2, whereas in python3, we have only new style classes.
		- IN python2, range, map, filter will return list; where these are iterators in python3.
	- Challenges during conversion
		- In python2, we can compare string and int; We cant do the same with python3
			- I wrote wrapper to handle it
		- DEPENDENCY MANAGEMENT is another difficult thing, as some modules are either not available in python3,
			or the latest features are not available in python3 modules.

- Virtual environment
	- It is like a container, for isolating the project dependencies
	- When in same server, we need to execute different versions, Or same python version, with different module
		versions, we go with a virtual environment.
	- virtual environments can be created using modules like
		- virtualenv
		- pipenv, or
		- poerty

	- Using virtualenv module,
		command to create virtual enviromment is
			virtualenv venv

		To activate the virtual enviromment,
			venv/scripts/active - in windows
			venv/bin/active - in linux/mac

- .py vs .pyc files
	❏ .py files contain the source code of a program. Whereas, .pyc file contains the bytecode of your
	program.
	❏ Python compiles the .py files and saves it as .pyc files, so it can reference them in subsequent
	invocations.
	❏ The .pyc contain the compiled bytecode of Python source files. This code is then executed by
	Python's virtual machine.

- Generators
	- are the functions with yield, instead of return
	- They are useful for large computations, like reading a large file, or creating 1000 prime numbers, or so.
	- Generators follow the "STATE SUSPENSION"
		- we can get one value at a time using next() builtin function,
			or iterate , or convert to list, tuple or set, to get all values
	- return vs yield
		- return is the last statement to execute in any function
		- yield is a keyword in python
			- If yield is placed within function definition, it becomes generator

		- PEP8 - don't use both return & yield in same function


		def grepper_gen():
			yield "add"
			yield "grepper"
			yield "answer"
		grepper = grepper_gen()

- Iterator
	- Any python iterable object can be converted to an intertor using iter() protocol
	- iterator can be created from any iterable object

- Decorators
	- Generally, when some code is repeating, we will create a function, reuse the code.
	- If there were more than one function, with some part of the code which is common among all,
      in that case, we extract common code, create a closure for it, and use it as a decorator.
	- built-in decorators are classmethod, staticmethod and property
	- I created custom decorators for calculating the time taken by functions, or
	  like logging the events, etc

- Map
	- Higher-order function, which is designed to work on other functions
	- map will superimpose a function on one or more iterables
	- say, we want to get double of all values in a list
		map(lambda x:x * 2, range(9))

	- In python2, map will result a list, where as in python3, it will return an iterator
	  object. Other higher order functions are Filter, Zip and Reduce
- Filter
	- This higher-order function will superimpose a function, on one or more iterables
	  and return the values, for whom the function returns boolean true.

- Zip
	- It will create pairs, on two or more iterables.
	- It will create pairs to the minimum size, among the iterables;
	  and discard asymmetric size values.

- Threading vs Asyncio
	Threading
		- In threading, OS actually knows about each thread and can interrupt it at
			any time to start running a different thread.
		- It is Pre-Emptive Multitasking
		- code in the thread doesn't need to do anything to make the switch.
		- difficult as OS can pause/resume thread "AT ANY TIME"
	Asyncio
		- Cooperative Multitasking
		- Tasks must cooperate by announcing when they are ready to be switched out.
		- You always know where your task will be swapped out.

- GIL Problem
	- GIL means Global Interpreter Lock
	- Simply, it means "One thread runs Python, while others sleep or await I/O."
	- In Cpython, as it go with reference based assignment, if two threads are trying to update,
	  say, the same list, it can lead to data races, and deadlock.
	- To avoid deadlocks, it will lock a single thread, safely execute it and release it.
	- Due to this, we can't achieve concurrency with python, unlike other languages.
	- Next solution is multiprocessing. But, it is resource exhaustive. And, the maximum limit
	 on the processes which can be created, is limited to the system hardware limits.
	- So, from python 3.6, with the advent of async and await keywords, I am using the asyncio
	 based non-blocking execution.
	- Here, within the single thread event loop, we will invoke all child threads; which is a solution
	  to this GIL problem

- Multiprocessing vs Multithreading
	- Multithreading for IO-bound tasks. Multiprocessing for CPU-bound tasks.
	- computationally-intensive tasks such as compression or hashing.

- stack & heap
	- each thread will have its own stack, but all the threads in a process will share the heap.

- thread vs process
	-------------------------------------------------------------------------------------------
		PROCESS								    |			THREAD
	-------------------------------------------------------------------------------------------
	- Processes are heavyweight operations.	    | Threads are lighter weight operations.
	- Each process has its own memory space.    | Threads use the memory of the process they belong to.
	- Inter-process communication is slow as    | Inter-thread communication can be faster than inter-process communication
	  processes have different memory addresses.| because threads of the same process share memory with the process they belong to.
	- Context switching between processes is    | Context switching between threads of the same process is less expensive
	  more expensive.
	- Processes don’t share memory with other   | Threads share memory with other threads of the same process.
	  processes.

- context managers
	- will allow you to allocate and release resources precisely when you want to.
	- Examples include when working with
		- file operations, database or socket connections, etc.
	- we can do with the 'with' keyword, like

		with open('file_name.txt', 'r') as fh:
			data = fh.read()

	- we need not close the file handler. Once it comes out of the context indentation, it will automatically close
I	- we can create custom context managers, using the dunder methods, __enter__() and __exit__().
	- I remember using it to track the file operations.

		class File:
		  def __init__(self, filename, method):
			self.file = open(filename, method)

		  def __enter__(self):
			print("Enter")
			return self.file

		  def __exit__(self, type, value, traceback):
			print(f"{type}, {value}, {traceback}")
			print("Exit")
			self.file.close()

		with File("file.txt", "w") as f:
		  print("Middle")
		  f.write("hello")
		  raise Exception()
		  raise FileExistsEoor()

- call by value vs call by reference
	- python supports both call by value and call by reference.
		- For immutables, it is call by values
			- by default, means changes within the function were not reflected outside
			- in variables are defined as global, local changes cAN be reflected outside
			  - that is in that case, it is call by reference
		- For immutables , if you define as global,  – it is be call by reference

unittesting
	- I used modules like unit test and pytest.
	- Generally, we follow TDD - test driven development
	- It means that first write the unit tests and then write logic to address them.
	- This way, we can assure that code is more reliable, handling all edge cases.
	- Also, any further logic changes, will be integrable easily, as all test cases need to pass,
	  before pushing the code

	In Unittesting, for each test suite, there will be
		a pair of class methods, called setup and tearDown
		and pair of instance methods, called setup and tearDown

			setup class method 		-- executes at the start of the test suite
			tearDown class method 	--  executes at the end of the test suite

			setup instance method 	-- executes at the start of each test case
			tearDown instance method – executes at end of each test case


- name mangling
	- python supports Public, private and protected variables/methods/functions
	- We can access even private variables, methods too  in python,
		But the convention is made to  avoid accidental override

	- Variable starting with no _underscores are called public variables
	- Variables starting with single underscore are called protected variables
	- variables starting with two underscores are called private variables
		- Also, variables starting with two underscores and ending with two underscores
		  are magic methods (or dunder/double underscore methods).
		- Ex: __init__ is the constructor
			  __del__ is the destructor
			  __enter__ and __exit__ are used for creating custom context managers
			  __iter__ and __next__ are used for creating Iterator objects.
			  __str__ and __repr__ are used for string representation of the instances


- Monkey patching is replacing a function/method/class by another at runtime,
   for testing purpses, fixing a bug or otherwise changing behaviour.

- namespaces
	LEGB - Local, Enclosed, Global, Builtin scopes

- py vs pyc
	- py extension files are ordinary python files
	- pyc extension files are python bytecode files,

- PEP 8
	- PEP is abbreviation for Python Enhancement Proposal
	- It deals with the coding style guide
	- It will list the best practices, in coding in python
	- These recommendations include
		- to use 4 spaces, and not tabs , for indentation
		- Use triple quotes for docstrings
		- Wrap lines so that they don’t exceed 79 characters, in each line
		- class names should in camel casing, and all others should be in underscore casing
		- Use Python’s default UTF-8 or ASCII encodings and not any fancy encodings
		- Blank Lines
			- Two blank lines should be both before and after class/method/function definitions.
			- You should use blank lines conservatively within your code to separate groups of functions.
		- One space around the operators
		- Wildcard imports (*) should not be preferred
		- Avoid trailing white-spaces

- Memory Management in python
	- Python has automatic memory management.
	- We have a garbage collector, which will check for any unreferenced objects
	  on a periodically, for each CPU clock cycle, and it will delete them.
	- Reference count is the number of references to an object.
	  When the reference count of an object drops to zero, it is deallocated.

	- we can check the reference count of any value using the sys module, sys.getreferencecount
	- The garbage collector can be controlled using the gc module.

Heap vs stack
	- Whenever an object is created, it’s always stored in the Heap space, and stack
	memory contains the reference to it.
	- Stack memory only contains local primitive variables and reference variables
	to objects in heap space.
	- Objects stored in the heap are globally accessible whereas stack memory can’t
	be accessed by other threads.
	- Memory management in stack is done in LIFO manner whereas it’s more complex in
	Heap memory because it’s used globally.
	- Stack memory is short-lived whereas heap memory lives from the start till the
	end of application execution.
	- Heap memory is used by all the parts of the application, stack memory is used
	only by one thread of execution.
	- When stack memory is full, Java runtime throws java.lang.StackOverFlowError
	  When heap memory is full, it throws java.lang.OutOfMemoryError: Java Heap Space error.
	- Stack memory is faster than heap memory.

Numpy
------
- How are numpy and pandas related
- numpy arrays

Pandas
------
- loc vs iloc
	- loc gets rows (or columns) with particular labels from the index.
	- iloc gets rows (or columns) at particular positions in the index (so it only takes integers).

- dataframe index
	- When index is unique, pandas use a hashtable to map key to value O(1).
	- When index is non-unique and sorted, pandas use binary search O(logN),
	  when index is random ordered pandas need to check all the keys in the index O(N).

- find differences between two dataframes
	df1=pd.DataFrame({'A':[1,2,3,3],'B':[2,3,4,4]})
	df2=pd.DataFrame({'A':[1],'B':[2]})

	pd.concat([df1,df2]).drop_duplicates(keep=False)

- dataframe to series
- series to dataframe
- uses of series
- vectorization
multi index pandas
- Feature Engineering
	- technique to create  new features from existing data that could help to gain more
	  insight into the data.
	- pandas.apply() for text extraction
	- pandas.groupby() and transform() for Aggregation Features
	- pandas.value_counts() and apply() for Frequency Encoding

- to read specific columns
	df = pd.read_csv("sample_file.csv", usecols=col_list)

spark
pyspark bucketby vs partitionby
pyspark compression parquet
spark splittable compression
sqlContext.setConf("spark.sql.parquet.compression.codec.", "snappy")
How to read large parquet file
map and reduce in big data



Q1) Describe truthy vs falsy
Ans) Python supports boolean type: True, False

bool() -- builtin function which will result the boolean-ness of the object in it.

For integers,
	0 			-> False
	non-zero 	-> True
For floats,
	0.0			-> False
	non-zero	-> True
	0.000001    -> True

For None		-> False

For boolean
	False		-> False
	True 		-> True

For empty collections,
	empty list 	[] 		-> False
	empty tuple () 		-> False
	empty set   set()	-> False
	empty dict 	{}		-> False

	with atleast one element, it is True

For relational and logical operations, based on result
	logical and --> will result in True, if all are True ONLY, else False
	logical OR  --> will result in False, if all are False ONLY, else True

Q2) How do you get the last item of a list?
Ans) we can use the reverse index to retrieve the last element from the list

 Ex: mylist = [23, 45,  6,  3, 23, 65,  2,   4]
			   0   1    2   3   4   5   6     7  <----- forward indexing
			   -8  -7  -6  -5  -4  -3  -2    -1  <------ reverse indexing

	lastnum = mylist[-1]

	Also, we can get indirectly (not preferred) by
		lastNum = mylist[len(mylist) - 1]

Q3) What does a leading _ (underscore) before a variable typically identify in python (used as a common naming convention)?
Ans) Python follows naming convention called name mangling for the variables/methods

	name 	-> Public variable  	- no leading underscores - can be accessed directly
	_name	-> Protected variables  - one leading underscore - can be accessed directly
	__name	-> Private variables 	- two leading underscores - prepend class name as protected variable before it to access
										Ex: _ClassName__name

	__name__ -> built-in variables, or dunder methods, or magic methods
				there are some specific methods, as such.

What is a magic method ( aka dunder method)?
Ans)
These are the builtin methods with some specific usage
As they start and end with two (double) underscores, they were called as dunder (double-underscore) methods.
Examples:
	__init__		constructor method - responsible for added default actions, after creating instance
	__del__			destructor method  - will invoke when deleting the instance
	__new__			method responsible for creating the instance, from a class

	__slot__				will restrict the attributes of class instance

	__enter__ & __exit__ 	used for creating custom context managers

	__iter__ & __next__ 	used for creating custom iterator classes


Also, if we create the class methods with dundermethods like __add__, then
with the instances, instead of addressing with this method names like

	instance1.__add__(instance2)

we can also do as below
	instance1 + instance2


Q4) What was introduced in python 3.6 that changed string formatting?
What do you prefer: f-string or .format()?
Ans)  String formattings in python
	- old style formatting  - using % with the specific data types
		Ex: language = "%s is rank %d language " %("python", 1)


	- new style formatting - using format() with placeholders, and not specific on data types
		Ex: language = "{0} is rank {1} language ".format("python", 1)

	- F-strings (from python 3.6)  -- advanced formatting
		Ex:
			lang = "python"
			rank = 1
			language = f"{lang} is rank {rank} language "

		Also, we can do computations within the braces to do more operations

			language = f"{lang.upper()} is rank {float(rank)} language "

	- F-string assignments ( from python 3.8)
		it will help in the debugging results.
		Instead of
			print("langauge = ", language)
			print("langauge = %s"% language)
			print("langauge = {}".format(language))
			print(f"langauge = {language}")

		we can write as
			print(f"{language =}"

Finally, among the three (old-style, new-style with format() and f-strings), the
F-string based formatting with take the least amount of time.

So, i prefer F-strings among all.


big data
	mapper - producer
	reduce - receiver
