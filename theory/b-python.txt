Python Modules 
	Requests 	     	: for consuming APIs
	Re   				: for regular expressions 
	Scikit-learn  		: for machine learning - I used for creating linear regression model
	BeautifulSoap 		: for parsing html content. Used when I worked on web crawling
	NumPy				: Advanced linear algebra and NumPy array operations
	SciPy				: Contains modules for optimization, linear algebra, and other essential data science functions.
	Matplotlib			: Visualization and data plotting in 2 or 3 dimensions.
	IPython				: Increasing console interactivity.
	SymPy				: Symbolic computation and computer algebra.
	Pandas				: Data manipulation and analysis, mainly through dataframes and tables.
	
Frameworks 
	Django , flask, fastapi 

Python Questions
=================
	- List vs Tuple 
		- List is mutable object, means we can edit the object like append, delete, ..
		- Tuple are faster than list
			- Tuples are stored in a single block of memory. Tuples are immutable so, 
			It doesn't require extra space to store new objects.
			- Lists are allocated in two blocks: 
				1. fixed one with all the Python object information, and 
				2. variable sized block for the data.
		- Tuples is that they use less memory where lists use more memory
		List is used when we need to make changes in code, say like adding values while loop . 
		Tuple is used when we wont change something in the code

	- append vs extend 
		- both adding elements in last of list 
		- with append, we can add either single element or an iterable
		- it will add at the end as it is 
		- whereas extend works with iterable objects only, but adds in same dimension
	- List vs Dict 
		- list is suitable when order of element is preferred. 
		- dict is suitable when there were more reads. dict has O(1) for search an element, as 
		  it stored each element uniquely with its hash.
	- List
		- Mutable object - it is editable. we can add , remove any element in it. 
		- indexed and retains the order of initialization 
		- will retain duplicates and can store any data type 
	- Tuple 
		- same as list, but once created, we cant change any element in it . 
		- it is immutable object 
	- Set 
		- mutable object - we can edit it 
		- unordered and wont store duplicates
		- will store only immutable objects(int, float, string, frozenset, tuple)
	- Dictionaries
		- They are called as HashMap in other languages
		- They store in key: value relation 
		- keys should be immutable and unique
		- ex: {1:2, 3:4, 5:6}
		
	- Pickling 
		- Pickling means Python object to flat file conversion 
		- unpickling means flat file to python object conversion 
		- This process is also called serialization/deserialization 
		- Other serialization formats are json, yaml, ...
		- we use it when we need to pass python object to other language processes, and vice versa.
		
	- lambda function
		- one liner
		- SYNATAX is lambda arguments: expression
		- We need not define complete function. We can use instantly for the purpose. 
		- I use it when working with higher order function like map(), filter(), zip() and reduce()
		
	- range() vs xrange() 
		- In python 2, 
			- range will give list of integers
			- xrange will give a xrange object, which will give values only when iterated.  
		- In python3, xrange is renamed as range.
	- copy vs deepcopy 
		- This problem occurs in mutable objects i.e., list, dictionary
		- when working with mutables, when we assign a
				list1 = list2 
			it will not create new object 
			it 
			both wil refer to the same object 
			so, if you change in one list, it will reflect in others 
			to avoid, we go with copy 
			using 
			copy -- module 
	- OOP 
		- Object Oriented Programming 
		- There are 4 principles:
			1) ENCAPSULATION - with public , protected and private variables/methods
					public variable -- it a variable is starting with no underscore 
					protected variable -- if it is starting with SINGLE underscore
					private variable -- if it is starting and ending with TWO underscores
				
				We can access all variables  of all classes irrespective of public or private or protected. 
				This name mangling is to avoid accidental override 
				
				
			2) ABSTRACTION: It is a process of hiding implementation details and showing only
							functionality to the user.
			3) INHERITANCE:
					- python supports single, multiple and multi-level inheritance, using MRO (Method Resolution Order) 
							single ---> one parent & one child 
							multiple --> two parents & one child 
							multi-level -->  parent1 => child ==> subChild
			4) POLYMORPHISM: It is an ability of object to behave in multiple form. 
				Ex: + operator, It will work differently in different contexts
							addition operation between integers
							List concatenation operator between lists
							Tuple concatenation operator between tuples
	- python 2 to 3
		- I used python built-in module, lib2to3 , for migrating from python2 to python3. 
		- Wrote code with six module to write compatible code, for both python2 and 3, during migrating phase.
		- Difference between python2 and python3 
			- Default encoding is ASCII in python2, whereas it  is UTF-8 in python3
			- There were both old & new style classes in python2, whereas in python3, we have only new style classes.
			- IN python2, range, map, filter will return list; where these are iterators in python3.
		- Challenges during conversion	
			- In python2, we can compare string and int; We cant do the same with python3
				- I wrote wrapper to handle it 
			- DEPENDENCY MANAGEMENT is another difficult thing, as some modules are either not available in python3,
				or the latest features are not available in python3 modules.
	- Virtual environment 
		- It is like a container, for isolating the project dependencies
		- When in same server, we need to execute different versions, Or same python version, with different module 
			versions, we go with a virtual environment.
		- virtual environments can be created using modules like
			- virtualenv
			- pipenv, or 
			- poerty

		- Using virtualenv module, 
			command to create virtual enviromment is 
				virtualenv venv
			
			To activate the virtual enviromment, 
				venv/scripts/active - in windows
				venv/bin/active - in linux/mac
						
	- Generators 
		- are the functions with yield, instead of return
		- They are useful for large computations, like reading a large file, or creating 1000 prime numbers, or so.
		- Generators follow the "STATE SUSPENSION"
			- we can get one value at a time using next() builtin function, 
				or iterate , or convert to list, tuple or set, to get all values
		- return vs yield
			- return is the last statement to execute in any function
			- yield is a keyword in python
				- If yield is placed within function definition, it becomes generator

			- PEP8 - don't use both return & yield in same function

			
			def grepper_gen():
				yield "add"
				yield "grepper"
				yield "answer"
			grepper = grepper_gen()
			
	- Threading vs Asyncio 
		Threading 
			- In threading, OS actually knows about each thread and can interrupt it at 
				any time to start running a different thread. 
			- It is Pre-Emptive Multitasking 
			- code in the thread doesn't need to do anything to make the switch. 
			- difficult as OS can pause/resume thread "AT ANY TIME"
		Asyncio	
			- Cooperative Multitasking 
			- Tasks must cooperate by announcing when they are ready to be switched out.
			- You always know where your task will be swapped out. 
	- GIL Problem 
		- GIL means Global Interpreter Lock 
		- Basically, Python is of three flavours, based on backend implementation 
			- Cpython, Jython, Ironthon
		- In Cpython, as it go with reference based assignment, if two threads are trying to update, 
		  say, the same list, it can lead to data races, and deadlock. 
		- To avoid deadlocks, it will lock a single thread, safely execute it and release it. 
		- Due to this, we cant achieve the concurrency with python, unlike other languages. 
		- Next solution, is multiprocessing. But, it is resource exhaustive. And, the maximum limit 
		 on the processes which can be created, is limited to the system hardware limits.
		- So, from python 3.6, with the advent of async and await keywords, I am using the asyncio 
		 based non-blocking execution. 
		- Here, within the single thread event loop, we will invoke all child threads; which is a solution 
		  to this GIL problem 
	- context managers
		- will allow you to allocate and release resources precisely when you want to.
		- Examples include when working with 
			- file operations, database or socket connections, etc.
		- we can do with the 'with' keyword, like 
		
			with open('file_name.txt', 'r') as fh:
				data = fh.read()
				
		- we need not close the file handler. Once it comes out of the context indentation, it will automatically close
	I	- we can create custom context managers, using the dunder methods, __enter__() and __exit__().
		- I remember using it to track the file operations.

			class File:
			  def __init__(self, filename, method):
				self.file = open(filename, method)
			   
			  def __enter__(self):
				print("Enter")
				return self.file
			  
			  def __exit__(self, type, value, traceback):
				print(f"{type}, {value}, {traceback}")
				print("Exit")
				self.file.close()

			with File("file.txt", "w") as f:
			  print("Middle")
			  f.write("hello")
			  raise Exception()
			  raise FileExistsEoor()


Numpy 
	- How are numpy and pandas related 
	- numpy arrays
	
Pandas 
	- loc vs iloc 
		- loc gets rows (or columns) with particular labels from the index.
		- iloc gets rows (or columns) at particular positions in the index (so it only takes integers).
	- dataframe index
		- When index is unique, pandas use a hashtable to map key to value O(1). 
		- When index is non-unique and sorted, pandas use binary search O(logN), 
		  when index is random ordered pandas need to check all the keys in the index O(N).
	- dataframe to series 
	- series to dataframe 
	- uses of series 
	- vectorization
	multi index pandas 


spark 
	pyspark bucketby vs partitionby
	pyspark compression parquet
	spark splittable compression
	sqlContext.setConf("spark.sql.parquet.compression.codec.", "snappy")
	How to read large parquet file 
	map and reduce in big data
	


Cybersecurity modules
----------------------
	1. Scapy
	2. Requests
	3. Beautiful Soup
	4. Socket
	5. Impacket
	6. Paramiko
	7. Pexpect
	8. Yara
	9. NLTK
	10. Twisted
	11. Pymetasploit3
	12. Cryptography 
	13. Nmap
	14. Scikit
	15. Mechanize