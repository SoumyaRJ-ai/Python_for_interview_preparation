Redis
	- data store that is also used as message queue
Apache Kafka
	- message queues with database-like durability guarantees
Elasticsearch/Solr
	- full text search server
Memcached
	- for in-memory cache


Reliability
	The system should continue to work correctly (performing the correct function at the desired level of performance) even in the face of adversity (hardware or software faults, and even human error). See “Reliability”.

Scalability
	As the system grows (in data volume, traffic volume, or complexity), there should be reasonable ways of dealing with that growth. See “Scalability”.

Maintainability
	Over time, many different people will work on the system (engineering and operations, both maintaining current behavior and adapting the system to new use cases), and they should all be able to work on it productively. See “Maintainability”.


failure vs fault
	A fault is usually defined as one component of the system deviating from its spec, whereas a failure is when the system as a whole stops providing the required service to the user.
It is impossible to reduce the probability of a fault to zero; therefore it is usually best to design fault-tolerance mechanisms that prevent faults from causing failures.


Netflix Chaos Monkey
	TO check the fault-tolerance,
		t can make sense to increase the rate of faults by triggering them deliberately—for example, by randomly killing individual processes without warning

Scalability is the term we use to describe a system’s ability to cope with increased load.

 response time is what the client sees: besides the actual time to process the request (the service time), it includes network delays and queueing delays. Latency is the duration that a request is waiting to be handled—during which it is latent, awaiting service [



monolithic vs microservice
==========================
In Monolithic,
	All components are part of a single unit
	Everything is developed, deployed and scaled as 1 unit
	App must be written with 1 tech stack
	Teams need to be careful to not affect each other's work
	1 single artifact, so you must redeploy the entire application on each update

	Challenges
		- Application is too large and complex
		- Parts are more tangledinto each other
		- You can only scale the entire app, instead of a spedicfic service.
		- Difficult if services need different dependency versions
		- Release process takes longer
		- On every change, the entire application needs to be tested
		- Entire applcation needs to be built and deployed
		- Bug in any modul can potentially bring down the entire application

In Microservices,
	Split application into smaller, independent services
	based on business functionalities
	Apps should be Loosely coupled
		Separation of concerns: means 1 service for 1 specific job
		Self-contained & independent
		Each microservice has its own version

	Communication should be via API calls
		Each service has its own API
		They can talk to each other, by sending requests to the respective  API endpoints
		Communication can be THREE ways
		1) In Synchronous communication,
			means each service waits for the response from another service.

		2) In asynchronous communication,
			communication is via messages using a message broker like RabbitMQ, etc
			common distribution patterns:
				Publish/Subscribe (PubSub)
				Point-to-Point messaging
		3) In Communication in Kubernetes using service Mesh,
			There will be a helper service which will take care of complete communication logic
			So, we need not code this logic into microservices

		Challenges
			- Configure the communication between services
			- More difficult to monitor with multiple instances of each service
			  distributed across servers

			In Kubernetes, serviceMesh, we can address both these challenges.

	ref - https://microservices.io/patterns/microservices.html

serviceMesh
	adds uniform networking capabilities across the stack in a way that is decoupled from application code
	Service meshes extend a cluster manager like Kubernetes to offer
		- observability metrics,
		- service discovery,
		- load balancing,
		- IT operations monitoring, and
		- failure recovery for microservices and containers.
	In market, to the best of my knowledge, for serviceMesh, there were tools like
		- Istio
		- Linkerd
		- Consul Connect
		- Kuma
		- Maesh
		- ServiceComb-mesher
		- Network Service Mesh (NSM)
		- AWS App Mesh
		- OpenShift Service Mesh by Red Hat

	AWS App Mesh is the tool, I used for serviceMesh
		AWS App Mesh makes it easy to run services by providing consistent visibility and network traffic controls, and helping you deliver secure services. App Mesh removes the need to update application code to change how monitoring data is collected or traffic is routed between services. App Mesh configures each service to export monitoring data and implements consistent communications control logic across your application.


Redis Usecases
---------------
	Slow latest items listings in your home page
	Leaderboards and related problems
	Order by user votes and time
	Implement expires on items
	Counting stuff
	Unique N items in a given amount of time
	Real time analysis of what is happening, for stats, anti spam, or whatever
	Pub/Sub
	Queues
	Caching

Airflow
	DAG means Directed Acyclic Graph.
	is a collection of all the tasks you want to run, organized in a way that reflects their relationships and dependencies.
	A DAG is defined in a Python script, which represents the DAGs structure (tasks and their dependencies) as code.
